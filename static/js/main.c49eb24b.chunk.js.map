{"version":3,"sources":["atoms/Dot.tsx","molecules/Food.tsx","molecules/Snake.tsx","random.ts","Game.ts","organisms/GameBox.tsx","organisms/Score.tsx","templates/GameField.tsx","pages/GamePage.tsx","App.tsx","serviceWorker.js","index.tsx"],"names":["ColoredBox","styled","div","props","color","y","x","Dot","Food","Snake","body","map","segment","key","getRandomInteger","max","Math","floor","random","getRandomIn","min","cMin","ceil","fMax","Game","isPlaying","_direction","snake","freeSpace","food","this","Array","FIELD_SIZE","i","direction","Error","offset","isArray","length","head","getRandomCoordinates","SNAKE_LENGTH","push","tbr","findIndex","coordinate","splice","console","error","find","newHead","newCoordinate","unshift","pop","moveHead","checkGameOver","isEating","spawnFood","moveTail","newDirection","gameInstance","Grid","GameBox","Score","points","GameArea","CounterBox","GameField","game","instance","initDirection","spawnSnake","updateFrame","setSnake","setFood","moveSnake","handleKeyPress","event","info","GamePage","useState","useEffect","document","addEventListener","interval","setInterval","removeEventListener","clearInterval","App","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"oZAWA,IAAMA,EAA0CC,IAAOC,IAAvC,KAGM,SAACC,GAAD,OAAWA,EAAMC,SACxB,SAACD,GAAD,OAAWA,EAAME,KAAO,SAACF,GAAD,OAAWA,EAAMG,KAAO,SAACH,GAAD,OAAWA,EAAME,EAAI,KAAO,SAACF,GAAD,OAAWA,EAAMG,EAAI,KAWjGC,EAF0B,SAAC,GAAD,IAAGD,EAAH,EAAGA,EAAGD,EAAN,EAAMA,EAAN,IAASD,aAAT,MAAiB,QAAjB,SAA+B,kBAACJ,EAAD,CAAYM,EAAGA,EAAGD,EAAGA,EAAGD,MAAOA,MCdxFI,EAF4B,SAAC,GAAD,IAAGF,EAAH,EAAGA,EAAGD,EAAN,EAAMA,EAAN,OAAc,kBAAC,EAAD,CAAKC,EAAGA,EAAGD,EAAGA,EAAGD,MAAM,YCYjEK,EAR8B,SAAC,GAAD,IAAGC,EAAH,EAAGA,KAAH,OAC3C,oCACGA,EAAKC,KAAI,SAACC,GAAD,OACR,kBAAC,EAAD,CAAKC,IAAG,UAAKD,EAAQN,EAAb,YAAkBM,EAAQP,GAAKC,EAAGM,EAAQN,EAAGD,EAAGO,EAAQP,U,wBCfzDS,EAAmB,SAACC,GAAD,OAAiBC,KAAKC,MAAMD,KAAKE,SAAWF,KAAKC,MAAMF,KAExE,SAASI,EAAYC,EAAaL,GAC/C,IAAMM,EAAOL,KAAKM,KAAKF,GACjBG,EAAOP,KAAKC,MAAMF,GACxB,OAAOD,EAAiBS,EAAOF,EAAO,GAAKD,ECHtC,IAUcI,E,WAanB,aAAuB,yBAVhBC,eAUe,OARdC,gBAQc,OANfC,WAMe,OAJfC,eAIe,OAFfC,UAEe,EACpBC,KAAKJ,YApBqB,EAqB1BI,KAAKH,MAAQ,GACbG,KAAKL,WAAY,EAEjBK,KAAKF,UAAY,IAAIG,MADQC,MAE7B,IAAK,IAAIC,EAAI,EAAGA,EAFaD,KAEaC,GAAK,EAG7CH,KAAKF,UAAUK,GAAK,CAAE3B,EAAI2B,EAhCN,GAgCwB,EAAG5B,EAAwB,KAAlB4B,EAhCjC,K,4DA8DtB,IA1D0B,IA0DtBH,KAAKI,UAA8B,MAAM,IAAIC,MAAM,0CACvDL,KAAKI,UAAYf,EAAY,EAAG,K,2CAGbiB,GACnB,MAAO,CAAE9B,EAAGa,EAAYiB,EAAS,EAnEX,GAmE2BA,GAAS/B,EAAGc,EAAYiB,EAAS,EAnE5D,GAmE4EA,M,mCAGtF,IAAD,OACX,GAAIL,MAAMM,QAAQP,KAAKH,QAAgC,IAAtBG,KAAKH,MAAMW,OAAc,MAAM,IAAIH,MAAM,2BAC1E,IApE0B,IAoEtBL,KAAKI,UAA8B,MAAM,IAAIC,MAAM,sCAEvD,IAAMI,EAAOT,KAAKU,qBAAqBC,GACvCX,KAAKH,MAAMe,KAAKH,GAChB,IAAII,EAAMb,KAAKF,UAAUgB,WAAU,SAACC,GAAD,OAAgBA,EAAWvC,IAAMiC,EAAKjC,GAAKuC,EAAWxC,IAAMkC,EAAKlC,KAGpG,OAFAyB,KAAKF,UAAUkB,OAAOH,EAAK,GAEnBb,KAAKI,WACX,KA3EuB,EA4ErB,IADF,eACWD,GACP,IAAMrB,EAAU,CAAEN,EAAGiC,EAAKjC,EAAGD,EAAGkC,EAAKlC,EAAI4B,GACzC,EAAKN,MAAMe,KAAK9B,GAChB+B,EAAM,EAAKf,UAAUgB,WAAU,SAACC,GAAD,OAAgBA,EAAWvC,IAAMM,EAAQN,GAAKuC,EAAWxC,IAAMO,EAAQP,KACtG,EAAKuB,UAAUkB,OAAOH,EAAK,IAJpBV,EAAI,EAAGA,EA/EI,EA+EcA,GAAK,EAAI,EAAlCA,GAMT,MACF,KAlFyB,EAmFvB,IADF,eACWA,GACP,IAAMrB,EAAU,CAAEN,EAAGiC,EAAKjC,EAAI2B,EAAG5B,EAAGkC,EAAKlC,GACzC,EAAKsB,MAAMe,KAAK9B,GAChB+B,EAAM,EAAKf,UAAUgB,WAAU,SAACC,GAAD,OAAgBA,EAAWvC,IAAMM,EAAQN,GAAKuC,EAAWxC,IAAMO,EAAQP,KACtG,EAAKuB,UAAUkB,OAAOH,EAAK,IAJpBV,EAAI,EAAGA,EAvFI,EAuFcA,GAAK,EAAI,EAAlCA,GAMT,MACF,KAzFwB,EA0FtB,IADF,eACWA,GACP,IAAMrB,EAAU,CAAEN,EAAGiC,EAAKjC,EAAGD,EAAGkC,EAAKlC,EAAI4B,GACzC,EAAKN,MAAMe,KAAK9B,GAChB+B,EAAM,EAAKf,UAAUgB,WAAU,SAACC,GAAD,OAAgBA,EAAWvC,IAAMM,EAAQN,GAAKuC,EAAWxC,IAAMO,EAAQP,KACtG,EAAKuB,UAAUkB,OAAOH,EAAK,IAJpBV,EAAI,EAAGA,EA/FI,EA+FcA,GAAK,EAAI,EAAlCA,GAMT,MACF,KAhGwB,EAiGtB,IADF,eACWA,GACP,IAAMrB,EAAU,CAAEN,EAAGiC,EAAKjC,EAAI2B,EAAG5B,EAAGkC,EAAKlC,GACzC,EAAKsB,MAAMe,KAAK9B,GAChB+B,EAAM,EAAKf,UAAUgB,WAAU,SAACC,GAAD,OAAgBA,EAAWvC,IAAMM,EAAQN,GAAKuC,EAAWxC,IAAMO,EAAQP,KACtG,EAAKuB,UAAUkB,OAAOH,EAAK,IAJpBV,EAAI,EAAGA,EAvGI,EAuGcA,GAAK,EAAI,EAAlCA,GAMT,MACF,QACEc,QAAQC,MAAM,0C,kCAKlB,GAAIjB,MAAMM,QAAQP,KAAKF,YAAwC,IAA1BE,KAAKF,UAAUU,OAClD,MAAM,IAAIH,MAAM,yCAEhBL,KAAKD,KAAOC,KAAKF,UAAUd,EAAiBgB,KAAKF,UAAUU,W,sCAQ9C,IAAD,cACUR,KAAKH,OAAtBY,EADO,gBAELU,MAAK,SAACJ,GAAD,OAAgBA,EAAWvC,IAAMiC,EAAKjC,GAAKuC,EAAWxC,IAAMkC,EAAKlC,OAC7EyB,KAAKL,WAAY,K,iCAKnB,IAAIyB,EACAC,EACJ,OAAQrB,KAAKI,WACX,KAvIuB,EAwIrBgB,EAAU,CAAE5C,EAAGwB,KAAKH,MAAM,GAAGrB,EAAGD,EAAGyB,KAAKH,MAAM,GAAGtB,EAAI,GA7InC,IA8IlB,MACF,KAzIyB,EA0IvB8C,EAAgBrB,KAAKH,MAAM,GAAGrB,EAAI,EAClC4C,EAAU,CAAE5C,EAAG6C,EAjJG,GAiJ0B,EAAIA,EAAe9C,EAAGyB,KAAKH,MAAM,GAAGtB,GAChF,MACF,KA5IwB,EA6ItB8C,EAAgBrB,KAAKH,MAAM,GAAGtB,EAAI,EAClC6C,EAAU,CAAE5C,EAAGwB,KAAKH,MAAM,GAAGrB,EAAGD,EAAG8C,EArJjB,GAqJ8C,EAAIA,GACpE,MACF,KA/IwB,EAgJtBD,EAAU,CAAE5C,EAAGwB,KAAKH,MAAM,GAAGrB,EAAI,GAxJf,GAwJgCD,EAAGyB,KAAKH,MAAM,GAAGtB,GACnE,MACF,QACE0C,QAAQC,MAAM,qCAElBlB,KAAKH,MAAMyB,QAAQF,GACnB,IAAMP,EAAMb,KAAKF,UAAUgB,WAAU,SAACC,GAAD,OAAgBA,EAAWvC,IAAM4C,EAAQ5C,GAAKuC,EAAWxC,IAAM6C,EAAQ7C,KAC5GyB,KAAKF,UAAUkB,OAAOH,EAAK,K,iCAI3Bb,KAAKF,UAAUc,KAAKZ,KAAKH,MAAMG,KAAKH,MAAMW,OAAS,IACnDR,KAAKH,MAAM0B,Q,kCAIXvB,KAAKwB,WACLxB,KAAKyB,gBACDzB,KAAK0B,SACP1B,KAAK2B,YAEL3B,KAAK4B,a,8BAjIKC,IAxCc,IA0CxBA,IA1CwB,IA2CxB7B,KAAKJ,aA1CkB,IA2CrBI,KAAKJ,YAzCiB,IAyCeI,KAAKJ,YA1CnB,IA2CtBiC,GAzCqB,IAyCeA,KA3Cd,IA4CvB7B,KAAKJ,YA1CiB,IA0CiBI,KAAKJ,YA3CtB,IA4CrBiC,GA9CoB,IA8CeA,KAEtC7B,KAAKJ,WAAaiC,I,eAKpB,OAAO7B,KAAKJ,a,+BAoEZ,OAAOI,KAAKH,MAAM,GAAGrB,IAAMwB,KAAKD,KAAKvB,GAAKwB,KAAKH,MAAM,GAAGtB,IAAMyB,KAAKD,KAAKxB,K,gCArFxE,OAJKyB,KAAK8B,eACR9B,KAAK8B,aAAe,IAAIpC,GAGnBM,KAAK8B,iB,mMA/BKpC,EACJoC,kB,ECPjB,IAAMC,EAAO5D,IAAOC,IAAV,IDJgB,OCwBX4D,EAPkC,SAAC,GAAD,IAAGnC,EAAH,EAAGA,MAAOE,EAAV,EAAUA,KAAV,OAC/C,kBAACgC,EAAD,KACE,kBAAC,EAAD,CAAMvD,EAAGuB,EAAKvB,EAAGD,EAAGwB,EAAKxB,IACzB,kBAAC,EAAD,CAAOK,KAAMiB,OCdFoC,EAF8B,SAAC,GAAD,IAAGC,EAAH,EAAGA,OAAH,OAAgB,oCAAGA,K,2jBCEhE,IAAMH,EAAO5D,IAAOC,IAAV,KAUJ+D,EAAWhE,IAAOC,IAAV,KAKRgE,EAAajE,IAAOC,IAAV,KAoBDiE,EAXsC,SAAC,GAAD,IAAGxC,EAAH,EAAGA,MAAOE,EAAV,EAAUA,KAAV,OACnD,kBAAC,EAAD,KACE,kBAACoC,EAAD,KACE,kBAAC,EAAD,CAAStC,MAAOA,EAAOE,KAAMA,KAE/B,kBAACqC,EAAD,KACE,kBAAC,EAAD,CAAOF,OAA6B,IAApBrC,EAAMW,OAAS,SCjC/B8B,EAAO5C,EAAK6C,SAClBD,EAAKE,gBACLF,EAAKG,aACLH,EAAKX,YAEL,IAAMe,EAAc,SAACC,EAAoBC,GACnCN,EAAK3C,YACP2C,EAAKO,YACLF,EAAS,YAAIL,EAAKzC,QAClB+C,EAAQN,EAAKvC,QAIX+C,EAAiB,SAACC,GACtB,OAAQA,EAAMhE,KACZ,IAAK,YACHuD,EAAKlC,UJXmB,EIYxB,MACF,IAAK,aACHkC,EAAKlC,UJhBoB,EIiBzB,MACF,IAAK,UACHkC,EAAKlC,UJpBkB,EIqBvB,MACF,IAAK,YACHkC,EAAKlC,UJrBmB,EIsBxB,MACF,QACEa,QAAQ+B,KAAKD,EAAMhE,OAoBVkE,EAhBE,WAAO,IAAD,EACKC,mBAASZ,EAAKzC,OADnB,mBACdA,EADc,KACP8C,EADO,OAEGO,mBAASZ,EAAKvC,MAFjB,mBAEdA,EAFc,KAER6C,EAFQ,KAarB,OATAO,qBAAU,WACRC,SAASC,iBAAiB,UAAWP,GACrC,IAAMQ,EAAWC,YAAYb,EAAa,IAAKC,EAAUC,GACzD,OAAO,WACLQ,SAASI,oBAAoB,UAAWV,GACxCW,cAAcH,MAEf,IAEI,kBAAC,EAAD,CAAWzD,MAAOA,EAAOE,KAAMA,KCvCzB2D,MARf,WACE,OACE,oCACE,kBAAC,EAAD,QCMcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MAAM,2DCXnCC,IAASC,OAAO,kBAAC,EAAD,MAASb,SAASc,eAAe,SDsH3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAACC,GAClCA,EAAaC,kB","file":"static/js/main.c49eb24b.chunk.js","sourcesContent":["import React, { FunctionComponent } from 'react';\n\nimport styled from 'styled-components';\nimport { withProps } from '../styled_component_with_props_decorator';\n\ninterface ColoredBoxProps {\n  color: string;\n  x: number;\n  y: number;\n}\n\nconst ColoredBox = withProps<ColoredBoxProps>()(styled.div)`\n  width: 100%;\n  height: 100%;\n  background-color: ${(props) => props.color};\n  grid-area: ${(props) => props.y} / ${(props) => props.x} / ${(props) => props.y + 1} / ${(props) => props.x + 1};\n`;\n\ninterface DotProps {\n  color?: string;\n  x: number;\n  y: number;\n}\n\nconst Dot: FunctionComponent<DotProps> = ({ x, y, color = 'black' }) => <ColoredBox x={x} y={y} color={color} />;\n\nexport default Dot;\n","import React, { FunctionComponent } from 'react';\nimport Dot from '../atoms/Dot';\n\nexport interface FoodProps {\n  x: number;\n  y: number;\n}\n\nconst Food: FunctionComponent<FoodProps> = ({ x, y }) => <Dot x={x} y={y} color=\"green\" />;\n\nexport default Food;\n","import React, { FunctionComponent } from 'react';\nimport Dot from '../atoms/Dot';\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface SnakeProps {\n  body: Array<Coordinates>;\n}\n\nconst Snake: FunctionComponent<SnakeProps> = ({ body }) => (\n  <>\n    {body.map((segment) => (\n      <Dot key={`${segment.x}_${segment.y}`} x={segment.x} y={segment.y} />\n    ))}\n  </>\n);\n\nexport default Snake;\n","export const getRandomInteger = (max: number) => Math.floor(Math.random() * Math.floor(max));\n\nexport default function getRandomIn(min: number, max: number) {\n  const cMin = Math.ceil(min);\n  const fMax = Math.floor(max);\n  return getRandomInteger(fMax - cMin + 1) + min;\n}\n","import getRandomIn, { getRandomInteger } from './random';\n\nexport const FIELD_SIZE = 50;\nexport const STANDARD_OFFSET = 2;\nexport const SNAKE_LENGTH = 4;\n\nexport const DIRECTION_NONE = -1;\nexport const DIRECTION_TOP = 0;\nexport const DIRECTION_RIGHT = 1;\nexport const DIRECTION_DOWN = 2;\nexport const DIRECTION_LEFT = 3;\n\nexport default class Game {\n  private static gameInstance: Game;\n\n  public isPlaying: boolean;\n\n  private _direction: number;\n\n  public snake: any[];\n\n  public freeSpace: any[];\n\n  public food: any;\n\n  private constructor() {\n    this._direction = DIRECTION_NONE;\n    this.snake = [];\n    this.isPlaying = true;\n    const freeSpaceArrayLength = FIELD_SIZE * FIELD_SIZE;\n    this.freeSpace = new Array(freeSpaceArrayLength);\n    for (let i = 0; i < freeSpaceArrayLength; i += 1) {\n      // Caution! Computer science below\n      // eslint-disable-next-line no-bitwise\n      this.freeSpace[i] = { x: (i % FIELD_SIZE) + 1, y: ~~(i / FIELD_SIZE) + 1 };\n    }\n  }\n\n  static get instance() {\n    if (!this.gameInstance) {\n      this.gameInstance = new Game();\n    }\n\n    return this.gameInstance;\n  }\n\n  set direction(newDirection: number) {\n    if (\n      newDirection === DIRECTION_NONE ||\n      this._direction === DIRECTION_NONE ||\n      ((this._direction === DIRECTION_TOP || this._direction === DIRECTION_DOWN) &&\n        (newDirection === DIRECTION_RIGHT || newDirection === DIRECTION_LEFT)) ||\n      ((this._direction === DIRECTION_RIGHT || this._direction === DIRECTION_LEFT) &&\n        (newDirection === DIRECTION_DOWN || newDirection === DIRECTION_TOP))\n    ) {\n      this._direction = newDirection;\n    }\n  }\n\n  get direction(): number {\n    return this._direction;\n  }\n\n  initDirection() {\n    if (this.direction !== DIRECTION_NONE) throw new Error('Direction can only be initialized once');\n    this.direction = getRandomIn(0, 3);\n  }\n\n  getRandomCoordinates(offset: number) {\n    return { x: getRandomIn(offset + 1, FIELD_SIZE - offset), y: getRandomIn(offset + 1, FIELD_SIZE - offset) };\n  }\n\n  spawnSnake() {\n    if (Array.isArray(this.snake) && this.snake.length !== 0) throw new Error('Snake is already spawn!');\n    if (this.direction === DIRECTION_NONE) throw new Error('You should specify direction first');\n\n    const head = this.getRandomCoordinates(SNAKE_LENGTH + STANDARD_OFFSET);\n    this.snake.push(head);\n    let tbr = this.freeSpace.findIndex((coordinate) => coordinate.x === head.x && coordinate.y === head.y);\n    this.freeSpace.splice(tbr, 1);\n\n    switch (this.direction) {\n      case DIRECTION_TOP:\n        for (let i = 1; i < SNAKE_LENGTH; i += 1) {\n          const segment = { x: head.x, y: head.y + i };\n          this.snake.push(segment);\n          tbr = this.freeSpace.findIndex((coordinate) => coordinate.x === segment.x && coordinate.y === segment.y);\n          this.freeSpace.splice(tbr, 1);\n        }\n        break;\n      case DIRECTION_RIGHT:\n        for (let i = 1; i < SNAKE_LENGTH; i += 1) {\n          const segment = { x: head.x - i, y: head.y };\n          this.snake.push(segment);\n          tbr = this.freeSpace.findIndex((coordinate) => coordinate.x === segment.x && coordinate.y === segment.y);\n          this.freeSpace.splice(tbr, 1);\n        }\n        break;\n      case DIRECTION_DOWN:\n        for (let i = 1; i < SNAKE_LENGTH; i += 1) {\n          const segment = { x: head.x, y: head.y - i };\n          this.snake.push(segment);\n          tbr = this.freeSpace.findIndex((coordinate) => coordinate.x === segment.x && coordinate.y === segment.y);\n          this.freeSpace.splice(tbr, 1);\n        }\n        break;\n      case DIRECTION_LEFT:\n        for (let i = 1; i < SNAKE_LENGTH; i += 1) {\n          const segment = { x: head.x + i, y: head.y };\n          this.snake.push(segment);\n          tbr = this.freeSpace.findIndex((coordinate) => coordinate.x === segment.x && coordinate.y === segment.y);\n          this.freeSpace.splice(tbr, 1);\n        }\n        break;\n      default:\n        console.error('I wish if JS had enums 😭');\n    }\n  }\n\n  spawnFood() {\n    if (Array.isArray(this.freeSpace) && this.freeSpace.length === 0) {\n      throw new Error(\"Can't spawn food. No free space left.\");\n    } else {\n      this.food = this.freeSpace[getRandomInteger(this.freeSpace.length)];\n    }\n  }\n\n  get isEating() {\n    return this.snake[0].x === this.food.x && this.snake[0].y === this.food.y;\n  }\n\n  checkGameOver() {\n    const [head, ...body] = this.snake;\n    if (body.find((coordinate) => coordinate.x === head.x && coordinate.y === head.y)) {\n      this.isPlaying = false;\n    }\n  }\n\n  moveHead() {\n    let newHead: any;\n    let newCoordinate: any;\n    switch (this.direction) {\n      case DIRECTION_TOP:\n        newHead = { x: this.snake[0].x, y: this.snake[0].y - 1 || FIELD_SIZE };\n        break;\n      case DIRECTION_RIGHT:\n        newCoordinate = this.snake[0].x + 1;\n        newHead = { x: newCoordinate > FIELD_SIZE ? 1 : newCoordinate, y: this.snake[0].y };\n        break;\n      case DIRECTION_DOWN:\n        newCoordinate = this.snake[0].y + 1;\n        newHead = { x: this.snake[0].x, y: newCoordinate > FIELD_SIZE ? 1 : newCoordinate };\n        break;\n      case DIRECTION_LEFT:\n        newHead = { x: this.snake[0].x - 1 || FIELD_SIZE, y: this.snake[0].y };\n        break;\n      default:\n        console.error('This is 2D snake paw 🐍');\n    }\n    this.snake.unshift(newHead);\n    const tbr = this.freeSpace.findIndex((coordinate) => coordinate.x === newHead.x && coordinate.y === newHead.y);\n    this.freeSpace.splice(tbr, 1);\n  }\n\n  moveTail() {\n    this.freeSpace.push(this.snake[this.snake.length - 1]);\n    this.snake.pop();\n  }\n\n  moveSnake() {\n    this.moveHead();\n    this.checkGameOver();\n    if (this.isEating) {\n      this.spawnFood();\n    } else {\n      this.moveTail();\n    }\n  }\n}\n","import React, { FunctionComponent } from 'react';\nimport styled from 'styled-components';\nimport Food, { FoodProps } from '../molecules/Food';\nimport Snake, { Coordinates } from '../molecules/Snake';\nimport { FIELD_SIZE } from '../Game';\n\nconst Grid = styled.div`\n  display: grid;\n  grid: repeat(${FIELD_SIZE}, 1fr) / repeat(${FIELD_SIZE}, 1fr);\n  width: 100%;\n  height: 100%;\n  border: 1px solid;\n`;\n\ninterface GameBoxProps {\n  snake: Array<Coordinates>;\n  food: FoodProps;\n}\n\nconst GameBox: FunctionComponent<GameBoxProps> = ({ snake, food }) => (\n  <Grid>\n    <Food x={food.x} y={food.y} />\n    <Snake body={snake} />\n  </Grid>\n);\n\nexport default GameBox;\n","import React, { FunctionComponent } from 'react';\n\ninterface ScoreProps {\n  points: number;\n}\n\nconst Score: FunctionComponent<ScoreProps> = ({ points }) => <>{points}</>;\n\nexport default Score;\n","import React, { FunctionComponent } from 'react';\nimport styled from 'styled-components';\n\nimport GameBox from '../organisms/GameBox';\nimport Score from '../organisms/Score';\nimport { Coordinates } from '../molecules/Snake';\nimport { FoodProps } from '../molecules/Food';\n\nconst Grid = styled.div`\n  display: grid;\n  grid:\n    [header-start] 'left-sidebar header right-sidebar' 25px [header-end]\n    [main-start] 'left-sidebar game right-sidebar' 600px [main-end]\n    [footer-start] 'left-sidebar counter right-sidebar' 50px [footer-end]\n    / 1fr 600px 1fr;\n  place-items: center;\n`;\n\nconst GameArea = styled.div`\n  grid-area: game;\n  place-self: stretch;\n`;\n\nconst CounterBox = styled.div`\n  grid-area: counter;\n`;\n\ninterface GameFieldProps {\n  snake: Array<Coordinates>;\n  food: FoodProps;\n}\n\nconst GameField: FunctionComponent<GameFieldProps> = ({ snake, food }) => (\n  <Grid>\n    <GameArea>\n      <GameBox snake={snake} food={food} />\n    </GameArea>\n    <CounterBox>\n      <Score points={(snake.length - 4) * 10} />\n    </CounterBox>\n  </Grid>\n);\n\nexport default GameField;\n","import React, { useState, useEffect } from 'react';\nimport GameField from '../templates/GameField';\n\nimport Game, { DIRECTION_LEFT, DIRECTION_DOWN, DIRECTION_RIGHT, DIRECTION_TOP } from '../Game';\n\nconst game = Game.instance;\ngame.initDirection();\ngame.spawnSnake();\ngame.spawnFood();\n\nconst updateFrame = (setSnake: Function, setFood: Function) => {\n  if (game.isPlaying) {\n    game.moveSnake();\n    setSnake([...game.snake]);\n    setFood(game.food);\n  }\n};\n\nconst handleKeyPress = (event: KeyboardEvent) => {\n  switch (event.key) {\n    case 'ArrowLeft':\n      game.direction = DIRECTION_LEFT;\n      break;\n    case 'ArrowRight':\n      game.direction = DIRECTION_RIGHT;\n      break;\n    case 'ArrowUp':\n      game.direction = DIRECTION_TOP;\n      break;\n    case 'ArrowDown':\n      game.direction = DIRECTION_DOWN;\n      break;\n    default:\n      console.info(event.key);\n  }\n};\n\nconst GamePage = () => {\n  const [snake, setSnake] = useState(game.snake);\n  const [food, setFood] = useState(game.food);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyPress);\n    const interval = setInterval(updateFrame, 100, setSnake, setFood);\n    return () => {\n      document.removeEventListener('keydown', handleKeyPress);\n      clearInterval(interval);\n    };\n  }, []);\n\n  return <GameField snake={snake} food={food} />;\n};\n\nexport default GamePage;\n","import React from 'react';\nimport GamePage from './pages/GamePage';\n\nfunction App(): any {\n  return (\n    <>\n      <GamePage />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.info(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.info('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.info('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.info(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}